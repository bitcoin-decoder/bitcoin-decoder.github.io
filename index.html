<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin Address Generator and Balance Checker</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/elliptic/6.5.4/elliptic.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/crypto-js.js"></script>
    <script>
        // Function to decode base58
        function base58Decode(base58) {
            const alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
            let result = BigInt(0);
            for (let i = 0; i < base58.length; i++) {
                result = result * 58n + BigInt(alphabet.indexOf(base58[i]));
            }
            let hex = result.toString(16);
            // Pad with leading zeros if necessary
            while (hex.length % 2 !== 0) {
                hex = '0' + hex;
            }
            return hex;
        }

        // Convert a hexadecimal string to bytes
        function hexToBytes(hex) {
            const bytes = [];
            for (let i = 0; i < hex.length; i += 2) {
                bytes.push(parseInt(hex.substr(i, 2), 16));
            }
            return new Uint8Array(bytes);
        }

        // Convert bytes to hexadecimal string
        function bytesToHex(bytes) {
            return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // Perform SHA-256
        function sha256(data) {
            const hash = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(data));
            return hash.toString(CryptoJS.enc.Hex);
        }

        // Perform RIPEMD-160
        function ripemd160(data) {
            const hash = CryptoJS.RIPEMD160(CryptoJS.enc.Hex.parse(data));
            return hash.toString(CryptoJS.enc.Hex);
        }

        // Generate the Bitcoin address from a public key
        function publicKeyToAddress(publicKeyHex) {
            const publicKeyBytes = hexToBytes(publicKeyHex);
            const sha256Hash = sha256(bytesToHex(publicKeyBytes));
            const ripemd160Hash = ripemd160(sha256Hash);

            const networkPrefix = '00'; // Bitcoin main network prefix
            const publicKeyWithPrefix = networkPrefix + ripemd160Hash;

            const checksum = sha256(sha256(publicKeyWithPrefix)).slice(0, 8); // First 4 bytes of double SHA256
            const addressHex = publicKeyWithPrefix + checksum;
            return base58Encode(addressHex);
        }

        // Perform base58 encoding
        function base58Encode(hex) {
            const alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
            let num = BigInt('0x' + hex);
            let result = '';
            while (num > 0) {
                result = alphabet[Number(num % 58n)] + result;
                num /= 58n;
            }
            return result;
        }

        // Decode the WIF and get the private key
        function decodeWIF(wif) {
            const decoded = base58Decode(wif);
            const privateKeyHex = decoded.slice(2, -8); // Remove version prefix and checksum
            return privateKeyHex;
        }

        // Generate a public key from a private key (using secp256k1 elliptic curve)
        function privateKeyToPublic(privateKeyHex) {
            const ec = new elliptic.ec('secp256k1');
            const key = ec.keyFromPrivate(privateKeyHex, 'hex');
            return key.getPublic(false, 'hex'); // Uncompressed public key
        }

        // Check Bitcoin address balance
        async function checkBalance(address) {
            try {
                const response = await fetch(`https://blockstream.info/api/address/${address}`);
                if (!response.ok) throw new Error("Failed to fetch balance.");
                const data = await response.json();
                return data.chain_stats.funded_txo_sum - data.chain_stats.spent_txo_sum;
            } catch (error) {
                console.error(error);
                return "Error fetching balance.";
            }
        }

        async function updateBalanceDisplay(address, elementId) {
            const balance = await checkBalance(address);
            document.getElementById(elementId).innerText = balance === "Error fetching balance."
                ? balance
                : `${balance} satoshis`;
        }

        // Handle WIF to Bitcoin address generation
        async function handleWIFInput() {
            const wifInput = document.getElementById("wifInput").value;

            if (!wifInput) {
                alert("Please enter a valid WIF.");
                return;
            }

            try {
                // Decode WIF to get the private key
                const privateKeyHex = decodeWIF(wifInput);
                if (!privateKeyHex) throw new Error("Invalid WIF format");

                // Generate the public key from the private key
                const publicKeyHex = privateKeyToPublic(privateKeyHex);

                // Generate the Bitcoin address from the public key
                const address = publicKeyToAddress(publicKeyHex);

                // Display the results
                document.getElementById("addressResult").innerHTML = `
                    <p><strong>Bitcoin Address:</strong> ${address}</p>
                    <p><strong>Private Key (Hex):</strong> ${privateKeyHex}</p>
                `;

                // Fetch and display balance
                updateBalanceDisplay(address, "address-balance");

            } catch (error) {
                alert("Error: " + error.message);
            }
        }

        // SHA-256 to Bitcoin Address Generator
        async function hashAndGenerate() {
            try {
                const word = document.getElementById("wordInput").value;
                const iterations = parseInt(document.getElementById("iterations").value);
                const resultDiv = document.getElementById("result");

                resultDiv.innerHTML = ""; // Clear previous results

                if (!word || isNaN(iterations) || iterations < 1) {
                    resultDiv.innerHTML = `<p style="color: red;">Please enter a valid word and a positive number of iterations.</p>`;
                    return;
                }

                // Perform the hashing
                let hash = word;
                for (let i = 0; i < iterations; i++) {
                    const encoder = new TextEncoder();
                    const data = encoder.encode(hash);
                    const digest = await crypto.subtle.digest("SHA-256", data);
                    hash = Array.from(new Uint8Array(digest)).map(b => b.toString(16).padStart(2, '0')).join('');
                }

                // Convert hash to private key
                const privateKeyHex = hash.slice(0, 64); // Take the first 64 characters

                // Generate the public key and Bitcoin address
                const compressedPublicKey = privateKeyToCompressedPublic(privateKeyHex);
                const uncompressedPublicKey = privateKeyToPublic(privateKeyHex);
                const compressedAddress = await publicKeyToAddress(compressedPublicKey);
                const uncompressedAddress = await publicKeyToAddress(uncompressedPublicKey);

                // Display results
                resultDiv.innerHTML = `
                    <p><strong>Private Key (Hex):</strong> ${privateKeyHex}</p>
                    <p><strong>Compressed Address:</strong> ${compressedAddress} <span id="balance-compressed">Loading balance...</span></p>
                    <p><strong>Uncompressed Address:</strong> ${uncompressedAddress} <span id="balance-uncompressed">Loading balance...</span></p>
                `;

                // Fetch and display balances
                updateBalanceDisplay(compressedAddress, "balance-compressed");
                updateBalanceDisplay(uncompressedAddress, "balance-uncompressed");
            } catch (error) {
                document.getElementById("result").innerHTML = `<p style="color: red;">Error: ${error.message}</p>`;
            }
        }

        // Generate compressed public key
        function privateKeyToCompressedPublic(privateKeyHex) {
            const ec = new elliptic.ec('secp256k1');
            const key = ec.keyFromPrivate(privateKeyHex, 'hex');
            return key.getPublic(true, 'hex'); // Compressed public key
        }
    </script>
</head>
<body>
    <h1>Bitcoin Address Generator and Balance Checker</h1>

    <!-- Wallet Balance Checker -->
    <h2>Check Wallet Balance</h2>
    <form onsubmit="event.preventDefault(); updateBalanceDisplay(document.getElementById('addressInput').value, 'wallet-balance');">
        <label for="addressInput">Enter Bitcoin Address:</label><br>
        <input type="text" id="addressInput" placeholder="Enter Bitcoin address here"><br><br>
        <button type="submit">Check Balance</button>
    </form>
    <p><strong>Balance:</strong> <span id="wallet-balance">---</span></p>

    <hr>

    <!-- SHA-256 to Bitcoin Address Generator -->
    <h2>SHA-256 to Bitcoin Address Generator</h2>
    <form onsubmit="event.preventDefault(); hashAndGenerate();">
        <label for="wordInput">Enter a word or phrase:</label><br>
        <input type="text" id="wordInput" placeholder="Enter your word here"><br><br>

        <label for="iterations">Number of Hash Iterations:</label><br>
        <input type="number" id="iterations" min="1" placeholder="Enter number of iterations"><br><br>

        <button type="submit">Generate</button>
    </form>
    <div id="result" style="margin-top: 20px;"></div>

    <hr>

    <!-- WIF to Bitcoin Address -->
    <h2>WIF to Bitcoin Address</h2>
    <form onsubmit="event.preventDefault(); handleWIFInput();">
        <label for="wifInput">Enter Private Key (WIF):</label><br>
        <input type="text" id="wifInput" placeholder="Enter your WIF here"><br><br>
        <button type="submit">Generate Bitcoin Address</button>
    </form>
    <div id="addressResult" style="margin-top: 20px;">
        <p><strong>Bitcoin Address:</strong> <span id="address-balance">---</span></p>
    </div>
</body>
</html>
