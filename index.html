<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin Address Generator and Balance Checker</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/elliptic/6.5.4/elliptic.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/crypto-js.js"></script>
    <script>
        // Function to check wallet balance and transaction count using the Blockstream API
        async function checkBalanceAndTxCount(address) {
            try {
                const response = await fetch(`https://blockstream.info/api/address/${address}`);
                if (!response.ok) throw new Error("Failed to fetch data.");
                const data = await response.json();

                // Ensure we safely access the data
                const balance = data.chain_stats ? (data.chain_stats.funded_txo_sum - data.chain_stats.spent_txo_sum) : 0;
                const transactionCount = data.chain_stats ? data.chain_stats.tx_count : 0;

                return { balance, transactionCount };
            } catch (error) {
                console.error(error);
                return { balance: "Error fetching balance", transactionCount: "Error fetching transaction count" };
            }
        }

        // Function to update the balance and transaction count on the page
        async function updateBalanceAndTxCountDisplay(address, balanceElementId, txCountElementId) {
            const { balance, transactionCount } = await checkBalanceAndTxCount(address);

            // Update balance display
            const balanceDisplay = (balance === "Error fetching balance") ? balance : `${balance} satoshis`;
            document.getElementById(balanceElementId).innerText = balanceDisplay;

            // Update transaction count display
            const txCountDisplay = (transactionCount === "Error fetching transaction count") ? transactionCount : `${transactionCount} transactions`;
            document.getElementById(txCountElementId).innerText = txCountDisplay;
        }

        // Main function to convert private key and display results
        async function privateKeyToAddressAndDisplay() {
            const privateKeyInput = document.getElementById("privateKeyInput").value;
            let privateKeyHex;

            // Check if the private key is in WIF format
            if (privateKeyInput.startsWith("5")) {
                privateKeyHex = wifToHex(privateKeyInput);
            } else {
                privateKeyHex = privateKeyInput;
            }

            const compressedPublicKey = privateKeyToCompressedPublic(privateKeyHex);
            const uncompressedPublicKey = privateKeyToPublic(privateKeyHex);
            const compressedAddress = await publicKeyToAddress(compressedPublicKey);
            const uncompressedAddress = await publicKeyToAddress(uncompressedPublicKey);

            // Display results
            document.getElementById("result").innerHTML = `
                <p><strong>Private Key (Hex):</strong> ${privateKeyHex}</p>
                <p><strong>Compressed Address:</strong> ${compressedAddress} <span id="balance-compressed">Loading balance...</span> <span id="txcount-compressed">Loading transactions...</span></p>
                <p><strong>Uncompressed Address:</strong> ${uncompressedAddress} <span id="balance-uncompressed">Loading balance...</span> <span id="txcount-uncompressed">Loading transactions...</span></p>
            `;

            // Fetch and display balances and transaction counts
            updateBalanceAndTxCountDisplay(compressedAddress, "balance-compressed", "txcount-compressed");
            updateBalanceAndTxCountDisplay(uncompressedAddress, "balance-uncompressed", "txcount-uncompressed");
        }

        // Function to convert WIF (Wallet Import Format) to Hex private key
        function wifToHex(wif) {
            const buffer = Buffer.from(wif, 'base58');
            const version = buffer[0];
            const privKey = buffer.slice(1, -4).toString('hex');
            return privKey;
        }

        // Convert private key (Hex) to public key (Uncompressed)
        function privateKeyToPublic(privateKeyHex) {
            const ec = new elliptic.ec('secp256k1');
            const key = ec.keyFromPrivate(privateKeyHex, 'hex');
            return key.getPublic(false, 'hex'); // Uncompressed public key
        }

        // Convert private key (Hex) to public key (Compressed)
        function privateKeyToCompressedPublic(privateKeyHex) {
            const ec = new elliptic.ec('secp256k1');
            const key = ec.keyFromPrivate(privateKeyHex, 'hex');
            return key.getPublic(true, 'hex'); // Compressed public key
        }

        // Function to convert public key (Hex) to Bitcoin address
        async function publicKeyToAddress(publicKeyHex) {
            const publicKeyBytes = hexToBytes(publicKeyHex);
            const sha256Hash = await sha256(publicKeyBytes);
            const ripemd160Hash = ripemd160(sha256Hash);

            const networkPrefix = '00'; // Bitcoin main network
            const publicKeyWithPrefix = networkPrefix + ripemd160Hash;

            const checksum = await doubleSha256(hexToBytes(publicKeyWithPrefix));
            const checksumHex = bytesToHex(checksum.slice(0, 4));

            const addressHex = publicKeyWithPrefix + checksumHex;
            return base58Encode(addressHex);
        }

        // Base58 encoding function
        function base58Encode(hex) {
            const alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
            const leadingZeros = hex.match(/^0+/)?.[0]?.length || 0;
            let num = BigInt('0x' + hex);
            let result = '';
            while (num > 0) {
                result = alphabet[Number(num % 58n)] + result;
                num /= 58n;
            }
            return '1'.repeat(leadingZeros / 2) + result;
        }

        // SHA-256 hashing function
        async function sha256(data) {
            const hash = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(bytesToHex(data)));
            return hexToBytes(hash.toString(CryptoJS.enc.Hex));
        }

        // RIPEMD-160 hashing function
        function ripemd160(data) {
            const hash = CryptoJS.RIPEMD160(CryptoJS.enc.Hex.parse(bytesToHex(data)));
            return hash.toString(CryptoJS.enc.Hex);
        }

        // Double SHA-256 hashing function
        async function doubleSha256(data) {
            const firstHash = await sha256(data);
            const secondHash = await sha256(firstHash);
            return secondHash;
        }

        // Convert Hex to Bytes
        function hexToBytes(hex) {
            const bytes = [];
            for (let i = 0; i < hex.length; i += 2) {
                bytes.push(parseInt(hex.substr(i, 2), 16));
            }
            return new Uint8Array(bytes);
        }

        // Convert Bytes to Hex
        function bytesToHex(bytes) {
            return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
        }
    </script>
</head>
<body>
    <h1>Bitcoin Address Generator and Balance Checker</h1>

    <!-- Form for checking wallet balance -->
    <div>
        <h2>Check Wallet Balance</h2>
        <form onsubmit="event.preventDefault(); updateBalanceAndTxCountDisplay(document.getElementById('addressInput').value, 'wallet-balance', 'wallet-txcount');">
            <label for="addressInput">Enter Bitcoin Address:</label><br>
            <input type="text" id="addressInput" placeholder="Enter Bitcoin address here"><br><br>
            <button type="submit">Check Balance</button>
        </form>
        <p><strong>Balance:</strong> <span id="wallet-balance">---</span></p>
        <p><strong>Transaction Count:</strong> <span id="wallet-txcount">---</span></p>
    </div>

    <hr>

    <!-- Form for private key to address conversion -->
    <h2>Private Key to Bitcoin Address Converter</h2>
    <form onsubmit="event.preventDefault(); privateKeyToAddressAndDisplay();">
        <label for="privateKeyInput">Enter Private Key (Hex or WIF):</label><br>
        <input type="text" id="privateKeyInput" placeholder="Enter your private key here"><br><br>
        <button type="submit">Generate Address</button>
    </form>

    <div id="result" style="margin-top: 20px;"></div>

</body>
</html>
