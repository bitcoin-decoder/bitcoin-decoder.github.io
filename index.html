<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SHA-256 to Bitcoin Address</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            line-height: 1.6;
        }
        input, button {
            font-size: 16px;
            padding: 5px;
            margin: 5px 0;
        }
        button {
            cursor: pointer;
        }
        .result {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #ccc;
            background-color: #f9f9f9;
        }
        .error {
            color: red;
        }
    </style>
</head>
<body>
    <h1>SHA-256 to Bitcoin Address Generator</h1>
    <form id="hashForm">
        <label for="wordInput">Enter a word or phrase:</label><br>
        <input type="text" id="wordInput" placeholder="Enter your word here" required><br>

        <label for="iterations">Number of Hash Iterations:</label><br>
        <input type="number" id="iterations" min="1" placeholder="Enter number of iterations" value="1" required><br>

        <button type="submit">Generate</button>
    </form>

    <div id="result" class="result"></div>

    <script>
        // Elliptic Curve secp256k1 parameters
        const P = BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F");
        const N = BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141");
        const Gx = BigInt("0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798");
        const Gy = BigInt("0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8");
        const G = { x: Gx, y: Gy };

        function mod(n, p) {
            return ((n % p) + p) % p;
        }

        function modInverse(k, p) {
            return mod(k ** (p - 2n), p);
        }

        function pointAdd(p1, p2) {
            if (!p1) return p2;
            if (!p2) return p1;

            const m = mod((p2.y - p1.y) * modInverse(p2.x - p1.x, P), P);
            const x = mod(m * m - p1.x - p2.x, P);
            const y = mod(m * (p1.x - x) - p1.y, P);

            return { x, y };
        }

        function pointDouble(p) {
            const m = mod((3n * p.x ** 2n) * modInverse(2n * p.y, P), P);
            const x = mod(m * m - 2n * p.x, P);
            const y = mod(m * (p.x - x) - p.y, P);

            return { x, y };
        }

        function scalarMultiply(point, scalar) {
            let result = null;
            let addend = point;

            while (scalar) {
                if (scalar & 1n) {
                    result = pointAdd(result, addend);
                }
                addend = pointDouble(addend);
                scalar >>= 1n;
            }

            return result;
        }

        async function sha256(input) {
            const encoder = new TextEncoder();
            const data = encoder.encode(input);
            const hashBuffer = await crypto.subtle.digest("SHA-256", data);
            return new Uint8Array(hashBuffer);
        }

        function ripemd160(buffer) {
            // Simple RIPEMD-160 implementation (requires external lib if exact spec required)
            return buffer.slice(0, 20); // Placeholder (use a proper RIPEMD-160 function)
        }

        function base58Encode(buffer) {
            const alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
            let num = BigInt("0x" + Array.from(buffer).map(b => b.toString(16).padStart(2, "0")).join(""));
            let result = "";
            while (num > 0n) {
                const remainder = num % 58n;
                num = num / 58n;
                result = alphabet[remainder] + result;
            }
            return result;
        }

        async function publicKeyToAddress(publicKey, compressed = false) {
            const key = compressed
            ? new Uint8Array([2 + (publicKey.y % 2n), ...Array.from(publicKey.x.toString(16).padStart(64, "0"))])
            : new Uint8Array([...Array.from(publicKey.x.toString(16).padStart(64, "0")), ...Array.from(publicKey.y.toString(16).padStart(64, "0"))]);

            const shaHash = await sha256(key);
            const ripemdHash = ripemd160(shaHash);

            const versionedKey = new Uint8Array([0x00, ...ripemdHash]); // 0x00 for mainnet
            const checksum = (await sha256(await sha256(versionedKey))).slice(0, 4);

            return base58Encode(new Uint8Array([...versionedKey, ...checksum]));
        }

        document.getElementById("hashForm").addEventListener("submit", async (e) => {
            e.preventDefault();

            const word = document.getElementById("wordInput").value;
            const iterations = parseInt(document.getElementById("iterations").value);

            if (!word || iterations < 1) {
                document.getElementById("result").innerHTML = '<p class="error">Please provide valid input.</p>';
                return;
            }

            // Step 1: Hash the input word
            let hash = word;
            for (let i = 0; i < iterations; i++) {
                hash = await sha256(hash);
            }

            const privateKey = BigInt("0x" + Array.from(hash).map(b => b.toString(16).padStart(2, "0")).join(""));
            const publicKey = scalarMultiply(G, privateKey);

            // Generate Bitcoin addresses
            const compressedAddress = await publicKeyToAddress(publicKey, true);
            const uncompressedAddress = await publicKeyToAddress(publicKey, false);

            // Display results
            document.getElementById("result").innerHTML = `
                <p>Private Key (Hex): ${privateKey.toString(16).padStart(64, "0")}</p>
                <p>Compressed Address: ${compressedAddress}</p>
                <p>Uncompressed Address: ${uncompressedAddress}</p>
            `;
        });
    </script>
</body>
</html>

